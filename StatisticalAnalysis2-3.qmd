---
title: "Statistical Analysis Chapters 2-3"
format: html
---
2.2 Creating Network Graphs

A graph is a mathematical representation of V(vertices) = nodes and E(edges) = links; can be directed or undirected

The R package igraph was developed specifically to handle larger network graphing projects with multiple layers of data

```{r}
install.packages("devtools")
install.packages("sand")
```

A small (aka: "toy") graph can be generated as using the graph.formula function:

```{r}
library(igraph)
g <- graph_from_literal(1-2, 1-3, 2-3, 2-4, 3-5, 4-5, 
                    4-6, 4-7, 5-6, 6-7)

plot(g)
````

This generates an undirected graph. It will also change shape and location of nodes every time it is rendered.

To generate a directional "toy" graph, additional math is needed:

```{r}
dg <- graph_from_literal(1-+2, 1-+3, 2++3)
plot(dg)
```

This creates connections from 1 to 2 and 3 and between 2 and 3. So, the negative indicates an outgoing direction and the postive an incoming.

To replace numbers with names in a directional graph an have the results print into the termal rather than rendering visually, simply substitute:

```{r}
dgn <- graph_from_literal(Sam-+Mary, Sam-+Tom, 
                          Mary++Tom)
print_all(dgn)
```

To create an adjacency list visualize simply print the output of the str function:

```{r}
str(g)
print_all(g)
```

To print a two-column edges list of vertex pairs use the get.edgelist function:

```{r}
el <- get.edgelist (dgn)
print (el)
```

Warning message returned: 
`get.edgelist()` was deprecated in igraph 2.0.0.
ℹ Please use `as_edgelist()` instead.

```{r}
elu <- as_edgelist(dgn)
print (elu)
```

The function get.adjacency will return the list in matrix form

```{r}
mat <- get.adjacency (dgn)
print (mat)
```

Warning message:
`get.adjacency()` was deprecated in igraph 2.0.0.
ℹ Please use `as_adjacency_matrix()` instead.

```{r}
matu <- as_adjacency_matrix(dgn)
print (matujh)
```

Can create subgraphs by taking a prespecified subset of another graph (induced subgraph) or by including or excluding a subset of vertices or edges from another graph

```{r}
h <- induced_subgraph(g, 1:5)
print (h)
```

```{r}
alsoh <- g - vertices(c(6,7))
print (alsoh)
```

```{r}
h <- h + vertices(c(6,7))
g <- h + edges(c(4,6),c(4,7),c(5,6),c(6,7))
print (g)
```

```{r}
h1 <- h
h2 <- graph_from_literal(4-6, 4-7, 5-6, 6-7)
g <- union(h1,h2)
print (g)
```

2.3 Decorating Network Graphs

Other data relevant but not always included in the network (ie: nodes and edges) can be considered and when the network is equipped with attributes it is referred to as decorating the graph. This is accomplished in igraph using the '$' operator. Both edge and vertex attributes may be discrete or continuous.

Graph with weighted edges is a weighted graph.

Combining one dataset of edges with a vertex variable dataset to produce vertex attributes:

```{r}
library (sand)
# g.lazega <- graph.data.frame (elist.lazega, directed = "FALSE", vertices = v.attr.lazega) Depreciated error
g.lazega <- graph_from_data_frame (elist.lazega, directed = "FALSE", vertices = v.attr.lazega)
g.lazega$name <- "Lazega Lawyers"

vcount (g.lazega)

ecount (g.lazega)

#list.vertex.attributes (g.lazega) Depreciated error

vertex_attr_names (g.lazega)
```

2.4 Talking About Graphs

Simple graphs (proper edges) vs multi-graphs (loops and multi-edges) can be determind by using is_simple

```{r}
# is.simple (g) Deprecated error
is_simple (g)
```

```{r}
mg <- g + edge (2,3)
str(mg)

is_simple (mg)
```

Transforming a multi-graph to weighted graph and therefore a simple graph:

```{r}
E(mg) $weight <- 1
wg2 <- simplify (mg)
is_simple (wg2)

str(wg2)

E (wg2) $weight
```

Use *neighbors* to determine vertices joined by edges. Also called *adjacent* vertices. The code below shows that 3, 4, and 6 are joined to 5 by edges in the toy graph 'g'

```{r}
neighbors (g, 5)
```

To determine if edges are joined by a common vertex and further how many edges are *incident* or joined determines the *degree* of a vertex:

```{r}
degree (g)
```

In diagrphas, vertex degree is replaced by *in-degree* and *out-degree* which counts edge directions pointed toward and away from nodes.

```{r}
degree (dgn, mode = "in")

degree (dgn, mode = "out")
```

Terms of movement for a graph:
*walk*: In network analysis, a "walk" refers to a sequence of connected nodes (vertices) within a network, where you can traverse from one node to another along the edges, allowing for repetition of both nodes and edges; essentially, it's a way to navigate through the network by moving from one point to another, potentially revisiting the same points multiple times. (AI Overview result for Google search: "what is a walk in a network analysis")
*length* of walk
*trails*: walks without repeated edges
*paths*: trails without repeated vertices
*circuit*: trail with same beginning and end vertices
*cycle*: walk of at least three, same beginning and ending vertices but all other vertices are distinct
*acyclic*: graph containing no cycles
*reachable*: vertex connected by walk to another vertex
*connected*: graph in which every vertex is reachable for every other
*component of a graph*: maximally connected subgraph and any other remaining vertex would ruin property of connectivity

```{r}
#g is connected

#is.connected (g) Deprecated error
is_connected(g)

#and therefore only consists of a single component

#clusters (g) Deprecated error
components (g)
$membership

$csize

$no
```

*Weakly connected* graph's underlying graph (result of stripping away the tails and head labels) is connected. *Strongly connected* graphs are defined so because every vertex is reachable from every other vertex (*u*) by a directed walk. Graph dg is weakly connected:

```{r}
is.connected (dg, mode = "weak")

is.connected (dg, mode = "strong")
```

Shortest *distance* between vertices is defined as the shortest path between vertices (aka: *geodesic*). Longest distance in a graph called *diameter*.

```{r}
diameter (g, weights = NA)
```

Different types of graphs illustrated:

```{r}
g.full <- make_full_graph(7)
g.ring <- make_ring(7)
g.tree <- make_tree(7, children=2, mode="undirected")
g.star <- make_star(7, mode="undirected")
par(mfrow=c(2, 2), mai = c(0.2, 0.2, 0.2, 0.2))
plot(g.full)
plot(g.ring)
plot(g.tree)
plot(g.star)
```

A *complete* graph's every vertex is joined to every other vertex by an edge. Concept of *completeness* useful in defining a *clique* which is a complete subgraph. All of the graphs created above are complete of the order N<sub>v<sub> = 7 because each vertex is connected to all of the other six vertices.

A graph in which every vertex has the same degree is a *regular* graph. A regular graph with a common degree (*d*) is a *d-regular* graph. For example, the ring graph plotted above is a 2-regular graph. An infinite standard lattice graph, like a checker board, is a 4-regular graph.

A connected graph with no cycles is a *tree*. The disjoint union of a tree graph is a *forest*. Trees are important in network analysis and serve as the key data structure in efficient designs of many computational algorithms. A diagraph with a tree as an underlying graph is called a *directed tree*. A *root* is a special vertex from which there is a directed path to every other vertex in the graph, which is called a *rooted tree*. A vertex preceding another root on a path from the root is an *ancestor*, and a vertex follow another is a *descendant*. Immediate ancestors are *parents* and immediate descendants, *children*. A vertex without children is a *leaf*. The distance from the root to farthest leaf is the *depth* of the tree. In the tree created above each vertex is the ancestor of 2 descendants (except for the leafs). The tree has a depth 2 with vertex 1 functioning as the root.

The *k-star* graph created is a special tree. It consists of 1 root and *k* leaves. It illustrates the vertex and its immediate neighbors without showing connectivity of neighbors to each other.

A *directed acyclic graph (DAG)* is an important generalization of a tree. It is directed, but with out directed cycles. Unlike a directed tree, its underlying graph doesn't have to be a tree, because in replacing arcs with undirected edges cycles may be created. Graph dg is direct but not a DAG because it contains a mutual edge (2-cycle):

```{r}
# is.dag (dg) Deprecated error
is_dag (dg)
```

This can be a useful computation algorithms to design on because it is efficient and takes advantage of the near-tree-like structure.

*Bipartite* graphs contain 2 sets of vertices which can be disjointed (V<sub>1<sub>, V<sub>2<sub>), but where edges have an endpoint in V<sub>1<sub> and an endpoint in V<sub>2<sub>.

The bipartite graph below shows relationship between actors and movies:

```{r}
g.bip <- graph_from_literal(actor1:actor2:actor3,
   movie1:movie2, actor1:actor2 - movie1,
   actor2:actor3 - movie2)
V(g.bip)$type <- grepl("^movie", V(g.bip)$name)
print_all(g.bip, v=T)
```

```{r}
proj <- bipartite_projection(g.bip)
print_all(proj[[1]])

print_all(proj[[2]])
```